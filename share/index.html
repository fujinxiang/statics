<!DOCTYPE html>
<html>

<head>
    <title>基于 WebRTC 传输</title>
    <script src="https://cdn.jsdelivr.net/gh/fujinxiang/statics/share/p2p-share.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.3/StreamSaver.min.js"></script>
    <script src="https://unpkg.com/vue@3.2.33/dist/vue.global.prod.js"></script>
</head>

<body>
    <h1>
        基于 WebRTC 传输
    </h1>
    <div>
        <input type="file" id="inputfile" />
    </div>

    <div id="container">
        <h2>已连接 peers</h2>
        <p v-for="peer in peers">{{peer.id}}</p>

        <h2>可共享文件</h2>
        <p v-for="item in files">{{item.name}} - {{item.size}}</p>

        <h2>可下载文件</h2>
        <button v-if="recFiles.length" onclick="downloadSegment()">下载</button>
        <p v-for="item in recFiles">{{item}}</p>
    </div>

    <script>
        const app = Vue.createApp({
            data() {
                return {
                    files: [],
                    peers: [],
                    recFiles: [],
                };
            },
        }).mount("#container");

        const input = document.querySelector('#inputfile');
        const settings = {
            useP2P: true,
            trackerAnnounce: ['wss://lingering-silence-5732.fly.dev'],
            peerRequestsPerAnnounce: 10,
            simultaneousP2PDownloads: 3,
            p2pDownloadMaxPriority: 20,
            p2pSegmentDownloadTimeout: 6000,
            webRtcMaxMessageSize: 64 * 1024 - 1
        };

        const SegmentsMemoryStorage = window.p2pShare.SegmentsMemoryStorage;
        const segmentsStorage = new SegmentsMemoryStorage({ cachedSegmentExpiration: 5 * 60 * 1000, cachedSegmentsCount: 100 });

        const P2PMediaManager = window.p2pShare.P2PMediaManager;
        const p2pManager = new P2PMediaManager(segmentsStorage, settings);


        const swarmId = '123456789';
        p2pManager.setStreamSwarmId(swarmId, swarmId);

        p2pManager.on("peer-connected", (peer) => {
            console.log("peer-connected", peer.id);
            app.peers.push({ id: peer.id });
        })

        let currentSegmentsMap = [];
        let currentIndex = 0;
        let writer;
        p2pManager.on("peer-data-updated", () => {
            const segmentsMap = p2pManager.getOverallSegmentsMap();
            currentSegmentsMap = segmentsMap;
            console.log(segmentsMap);

            const recFilename = [...currentSegmentsMap][0][0].split('*')[0];
            app.recFiles.push(recFilename);

            const fileStream = streamSaver.createWriteStream(recFilename);
            writer = fileStream.getWriter();
        })



        p2pManager.on("segment-loaded", (segment, data, peerId) => {
            console.log("segment-loaded", segment, data, peerId);

            // const str = String.fromCharCode.apply(null, new Uint8Array(data));
            // console.log(str);

            writer.write(new Uint8Array(data));

            if (currentIndex < [...currentSegmentsMap].length - 1) {
                downloadSegment(currentIndex + 1);
            } else {
                writer.close();
            }
        })

        input.addEventListener('change', (e) => {
            const file = e.target.files[0];
            console.log(file);

            app.files.push({ name: file.name, size: file.size });

            var reader = new FileReader();
            reader.readAsArrayBuffer(file);
            reader.onload = async () => {
                arraybuffer = reader.result;
                console.log(arraybuffer);

                let segmentData = arraybuffer;

                const { segments, segmentsMap } = getSegmentsAndMap(file.name, file.size, arraybuffer);

                for (let i = 0; i < segments.length; i++) {
                    const segment = segments[i];
                    await segmentsStorage.storeSegment(segment)
                }

                p2pManager.sendSegmentsMapToAll(segmentsMap);
            };
        });

        function getSegmentsAndMap(name, size, data, segmentLength) {
            const length = segmentLength || 16384 * 16 * 16;
            const ceil = Math.ceil(size / length);
            const floor = Math.floor(size / length);
            const segmentCount = ceil;
            const lastSegmentLength = size - length * floor;

            const segments = []
            for (let i = 0; i < floor; i++) {
                const buf = data.slice(i * length, i * length + length);
                segments.push({
                    id: `${name}*${i}`,
                    masterSwarmId: '',
                    masterManifestUri: '',
                    priority: 1,
                    sequence: i,
                    data: buf
                })
            }

            segments.push({
                id: `${name}*${floor}`,
                sequence: floor,
                masterSwarmId: '',
                masterManifestUri: '',
                priority: 1,
                data: data.slice(length * floor)
            });

            const ids = segments.map(x => x.id);
            const segmentsMap = {};

            segmentsMap[name] = [ids.join('|'), Array.from({ length: ids.length }).fill(0)];

            return { segments, segmentsMap };
        }

        function downloadSegment(index) {
            currentIndex = index || 0;
            const item = [...currentSegmentsMap][currentIndex];
            p2pManager.download({ id: item[0] });
        }

    </script>
</body>

</html>